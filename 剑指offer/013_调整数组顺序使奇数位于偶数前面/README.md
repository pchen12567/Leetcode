## 题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，
所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

## 思路
- 思路一 <br>
    我们一开始的想法肯定是遍历整个列表，判断每一个元素是奇数还是偶数，奇数放到一个列表中，偶数放到另一个列表中，
    最后合并这两个列表。时间复杂度是O(2n+k)，空间复杂度S(2n)。
- 思路二 <br>
    若要使用更少的空间，还可以只使用一个额外的列表，奇数添加到列表的开头(添加到list的头部需要使用insert()方法，
    此方法的时间复杂度是O(n))，偶数添加到列表的结尾。时间复杂度是O(n^2)，空间复杂度是S(n)。
- 思路三 <br>
    若是要求原地修改，那么就不能使用额外的列表，每碰到一个偶数，则拿出这个数字，并把位于这个数字后面的所有数字往前挪动一位。
    挪完之后再列表的末尾会出现一个空位，这是就可以将这个偶数放到这个空位，但是这样的时间复杂度是O(n^2)，空间复杂度为S(1)。
- 思路四 <br>
    定义两个int型变量p_odd和p_search，p_odd指向左半段已经排好序的“前奇后偶”数组中最后一个奇数的位置；
    p_search始终位于p_odd的右边，指向数组右半段中出现的第一个奇数的位置。<br>
    定位p_search之后，依次与区间array[p_odd,p_search]之间的数值进行交换
- 思路五 <br>
    类似于快排的思路，使用两个指针，一个指针指向奇数(p1)，一个指针指向偶数(p2)，每次遍历过程中，遇到奇数(或偶数)，
    则停止移动p1(p2)，然后移动指针p2(p1)，直到遇到偶数(奇数)为止，然后交换这两个指针所指向的这一对奇偶数。
    时间复杂度O(nlogn)，空间复杂度S(1)。<br>
    **该算法会改变相对位置**
